[
["index.html", "Phylogenetic Biology Preface 0.1 Associated skills", " Phylogenetic Biology Casey W. Dunn 2020-08-22 Preface I developed this book as a collection of the concepts, methods, and applications that I most wanted to share with students in my Phylogenetic Biology courses. 0.1 Associated skills Comfort at the command line, manipulation of text files. Practical Computing for Biologists. Basic literacy with the programming language R. R for Data Science. Basic statistics, in particular probability theory. Some math, in particular an understanding of matrices and manipulations of matrices. "],
["intro.html", "Chapter 1 Introduction 1.1 Why phylogenies matter 1.2 Additional resources", " Chapter 1 Introduction Phylogenetic biology is the study of evolutionary relationships. There are three components to a phylogenetic analysis: characters, evolutionary models, and phylogenetic trees. In any given study we could have data, not care, or want to infer any three of these. When we don’t care, we marginalize. When we have data we fix. When we want to infer we estimate. This gives a broad range of hypothetical phylogenetic investigations. Only a subset of these are common in the literature, due to the questions that drive the field right now, the available data, and the methods that have been implemented in software tools. When we want to infer phylogenetic trees, we usually fix the characters at the tips using our data, marginalize over historical character states, estimate models, and estimate the tree. When we want to infer the history of character evolution, we often fix the tree, fix the characters at the tips using our data, estimate the model, and estimate the character history. But we can also marginalize over models, for example. 1.1 Why phylogenies matter History of life on earth Phylogenetic systematics Comparative methods Processes of evolution Current and future evolution (eg epidemiology) 1.2 Additional resources "],
["phylogenies.html", "Chapter 2 Phylogenies 2.1 Phylogenies are graphs 2.2 Drawing phylogenies 2.3 Some properties of trees 2.4 Rotating nodes 2.5 The meaning of edge lengths 2.6 Naming nodes and groups 2.7 Polytomies 2.8 Rooting 2.9 The information contained in phylogenies 2.10 Representation 2.11 Additional reading", " Chapter 2 Phylogenies Figure 2.1: Darwin’s depiction of the evolutionary relationships between organisms (Darwin 1859). Phylogenies represent evolutionary relationships. The only figure in Darwin’s Origin of Species (Darwin 1859) was a phylogeny (Figure 2.1), though he didn’t call it that. Phylogenies are often referred to as trees. It is an apt analogy. From the anchoring of the tree at a root, to the depiction of lineages as branches, to the presentation of tips as leaves, there is a direct correspondence. Many of the first speculative phylogenies were illustrated as actual trees, including Haekel’s tree in the manuscript where he coined the term phylogeny (Figure 2.2). Figure 2.2: Haeckel’s hypothesis of the animal phylogeny (Haeckel 1897), drawn as an actual tree. Not all trees in biology are phylogenies, though. For example, hierarchical clustering of traits across species results in trees that represent similarity similarity of species, but does not necessarilly show evolutionary relationships. In some cases phylogeny and species clustering will be largely congruent, but in many cases they will not be. Hierarchical tree-like clustering is also used for things that have no evolutionary component, like similarity of responses to a drug. It is helpful, then, to be more precise about the components of a phylogeny, and what each of those parts represent. 2.1 Phylogenies are graphs in order to establish a strong foundation for thinking about phylogenies, it is helpful to turn to math. Figure 2.3: A simple graph. Nodes are represented by circles, and edges by lines. Note that this graph has a cycle (you could walk in a circle between nodes 1, 2, and 4). It is also not bifurcating, as nodes have from one to four edges connected to them. A phylogeny is a specific instance of a mathematical object known as a graph. A graph consists of nodes, often represented as circles, connected by edges, often represented by lines (Figure 2.3). Graphs are useful representations of a variety of systems. For example, nodes could be people, and edges family relationships, connections in a social network, or financial transactions. Because it makes it easier to learn from adjacent fields when using mathematical conventions that are shared across fields, I will tend to use mathematical notation for phylogenies rather than the classical botanical nomenclatures. I will refer to edges rather than branches, tip nodes rather than leaves, etc… Figure 2.4: A graph representing a phylogeny. The tip nodes typically represent sampled entities, like living organisms, sequenced genes, or fossils. The internal nodes are ancestors that immediately precede divergence events. The root is a special internal node that has no parent. It is acyclic (ie, there are no paths that go in circles). The graph is bifurcating– the root node has two edges that connect it to its children, the other internal nodes each have three edges (one that connects to the parent, two to children), and the tips each have one edge (that connects to their parents). Phylogeny graphs (Figure 2.4) usually have a few specific topological properties: They are acyclic. This means that there is only one possible path along edges from one node to another. It isn’t possible to go in circles. Exceptions can arise in cases of horizontal gene transfer or hybridization. They tend to be bifurcating. This means that each internal node has one parent node and two daughter nodes, and therefore three edges connected to it. This represents the biological understanding of speciation, which usually proceeds by one lineage giving rise to two lineages. They can be directed. This means that edges are not symmetric, and instead have directionality. Specifically, they denote time. The node on one end of the edge is older than the node on the other side of the edge. We therefore can refer to the nodes connected to a particular edge as the parent node and child node. A phylogenetic graph is an abstraction, and for it to be useful it is important to keep in mind what features of biology we are attempting to represent. The nodes are entities that can evolve, like organisms or genes. The edges indicate evolutionary relationships between those entities. You could imagine as, an extreme case, a graph that showed every single individual that ever existed in your group of interest, say mammals. Each edge would connect literal parents and offspring. That would be a big phylogeny, and you would never have enough information to know it all, but it does exist even if unknowable and unwieldy given our current tools. A phylogeny is a subset of that graph, where we often retain a single individual per species as the tip nodes, and retain nodes immediately preceding divergence events as the internal nodes. In this respect, a phylogeny is a subgraph of the entire history of life on Earth. 2.2 Drawing phylogenies Here we will work with some mammal phylogenies, mostly because their silloutte icons are so recognizable and because there are extensive phylogenies available for this group (Upham, Esselstyn, and Jetz 2019). You will rarely see a phylogeny depicted as in Figure 2.4, with a circle for every node. It gets too cluttered. Instead, it is simpler to draw just the edges (Figure 2.5), with the nodes implied at the ends of edges. The nodes are implied. Figure 2.5: A phylogeny of some mammals, downloaded from http://vertlife.org . Note that node circles are not drawn, instead nodes are implied at ends of edges. There is considerable variation in how the same phylogeny can be drawn (Figure 2.6). This gives some flexibility in deciding what presentation is best for your particular goals, but can also create confusion because two images that look very different may in fact be of the exact same phylogeny. Rectangular layouts are the most common, because the entire edge length is along one axis of the plot. In a rectangular tree, each node is depicted as a line that is orthogonal to the edges. The confusing thing is that, because this line has the same width and color as the edges, it looks as if it is part of the edge. It isn’t though– its length is arbitrary, and it just shows which edges attach to that node. It also adds right-degree elbows where the ends of the node lines connect to the edges, forming a corner. Slanted layouts avoid the node lines and elbows of rectangular layouts, but because the edges aren’t parallel and can be at a variety of angles, it isn’t always easy to read edge lengths on them. Circular layouts place the root at the center, and the tips around the circumference. This is a compact representation that works well for very large phylogenies. Figure 2.6: The same tree as above, layed out in several different ways. 2.3 Some properties of trees In a fully bifurcating phylogeny with \\(n\\) tip nodes, the following will be the case: There are \\(n-1\\) internal nodes. For example, Figure 2.4 shows a phylogeny with 4 tip nodes (labeled 1-4) and 3 internal nodes (labeled 5-7). The total number of nodes (tip nodes and internal nodes) is therefore \\(2n-1\\). Each tip node has a single edge, which connects it to its parent node. The root node, which is a special internal node that is older than all other nodes, has no parent edge, so it has only two edges. These connect it to its immediate descendant nodes (its children). All internal nodes in the tree other than the root have three edges - one connected to a parent node, and two connected to child nodes. Since every edge in the tree has a single child node, and each node in the tree except for the root as a parent edge, the total number of edges in the tree is \\(2n-2\\). The number of possible topologies gets big really, really fast as \\(n\\) increases. The number of possible rooted phylogenies for \\(n\\) tips is \\((2n-3)!!\\). That is two factorials, not two exclamation points. Wow!! So, for a phylogeny of 5 tips there are possible topologies. For a phylogeny of 15 tips there are possible topologies. For a phylogeny of 50 tips there are possible topologies. This very large number of possible trees is a major challenge when it comes to inferring phylogenies from data - it is impossible to consider all possibilities. 2.4 Rotating nodes One of the most important things to keep in mind when interpreting a phylogeny is that the order of the tips doesn’t specify any information. You can rotate any internal node, changing the order of the tips, and you still have the exact same phylogeny, just drawn a different way (Figure 2.7). The topology remains unchanged. It’s the connections that tell us about the relationships. JD Laurence-Chasen, a former student in my invertebrate zoology course, made an excellent video about this – https://vimeo.com/148794860 . The major implication of this is that you should never read a tree across the tips to see, for example, which species are more closely related. You always need to look at the structure of the tree itself. Figure 2.7: The exact same phylogeny, drawn a few times with different node rotations. 2.5 The meaning of edge lengths Another source of variation to keep in mind is the meaning of edge length (Figure 2.8). A phylogeny where edge lengths are scaled to time is known as a chronogram. Chronograms of organisms all sampled at the same time will be ultrametric, ie the tip nodes will be flush. If tips are sampled at different times, for example when including fossils or sampling a rapidly evolving virus at different time points, they will not be ultrametric. In many cases we don’t have the information needed to scale edges to time, which requires fossil calibrations. Most published phylogenies therefore scale the edges according to the expected amount of evolutionary change in the characters under consideration. The rate of evolution usually varies a bit across edges, so phylograms are not usually ultrametric. Sometimes we are only interested in, or only have information about, the topology of the phylogeny. In this case we can draw the edges whatever length we want, and we call the phylogeny a cladogram. Cladograms can also be useful for showing annotations on edges in phylogenies with a wide variation in edge lengths, since there might not be enough room to write labels on very short edges. It is always good practice whenever you show a phylogeny to indicated whether it is a chronogram, phylogram, or cladogram. This is inconsistent int he literature, though, and if you aren’t sure it is best to just ignore edge lengths at treat the phylogeny as if it were a cladogram. Figure 2.8: Several types of trees. In a chronogram, edge lengths are scaled according to time. In a phylogram, edge lengths are scaled according to expected amount of evolutionary change, which can differ across characters and edges. In a cladogram, the edge lengths have no meaning. 2.6 Naming nodes and groups One of the most useful applications of phylogenies is to concisely refer to sets of organisms in light of their evolutionary history. A convenient way of designating sets of organisms is by their most recent common ancestor (MRCA). One of the core concepts in phylogenetic biology is the clade - a group of tips that includes all the descendants from their MRCA. A group is said to be monophyletic if it satisfies these creteria (you don’t need to use the double descriptor “monophyletic clade”, since a clade is by definition monophyletic). Since internal nodes are included in this definition, you can think of a monophyletic group as a subtree that is formed by clipping just below the MRCA. Any internal node in a rooted phylogeny can be described as the MRCA of two or more tips. You can therefore use sets of tips to designate a particular internal node, and then use that node to define a clade. For example, we could clearly designate mammals as all the descendants of the MRCA of humans and duck billed platyups. This is a very compact and unambiguous way to name groups of organisms. In fact, an entire biological nomenclature has been built with phylogenetically defined names like these (Queiroz and Cantino 2020). Not all groups are monophyletic. For example, the group consisting of kangaroos, people, and rabbits to the exclusion of all other mammals is not monophyletic. Their MRCA is easy enough to find, and once found it is clear that not all descendants of this node are included in the group. Slightly different terminology is used for such groups depending on how we think about internal nodes and edges. If we think of this set of non-monophyletic tips as isolated tips, to the eclusion of the MRCA, then we say the group is polyphyletic. If we think of it as including the MRCA but excluding all the other tips descended from that MRCA that are not in the group, then we call it paraphyletic. 2.7 Polytomies Some phylogenies are not strictly bifurcating. An internal node with more than two edges connecting it to descendants is called a polytomy. This can be either due to uncertainty about branching order (a soft polytomy) or multiple divergence events in very quick succession, giving rise at effectively the same time to more than two lineages (a hard polytomy). Any internal node with more than two descendants can be converted to a polytomy by collapsing some edges and deleting some nodes (Figure 2.8B-D). A phylogeny that consists entirely of a single polytomy is said to be entirely unresolved – it has no topological information. When laid out in a rectangular format, it looks like a comb (Figure 2.8D). When laid out in a slanted format it looks like a star. So you will hear fully unresolved trees referred to as comb or star phylogenies. Figure 2.9: (A) The fully resolved mammal tree used in other figures. (B-C) Different polytomies created in this tree by collapsing some groups. (D) A fully unresolved comb tree. 2.8 Rooting All the phylogenies we we have see so far are rooted - we know what the oldest point is in the tree, and call it the root node. This special internal node has no edge connecting it to a parent node (because it has no parent in the phylogeny), and all other nodes in the phylogeny are its descendants. One consequence of having a rooted tree is that we know the direction of time along each edge - time proceeds from the root to the tips. This provides a clear parent-child relationship between nodes at the ends of each edge. Not all phylogenis are rooted. Sometimes we just don’t care– some questions and methods don’t depend on where the root is, so we don’t have to bother placing it. Sometimes we just don’t know– placing the root is in a phylogeny takes information that sometimes we don’t have. There are many phylogenetic studies focused on identifying the location of the root in various groups of organisms, this is often an interesting and important question. Even when we don’t know where the root of a phylogeny is, we often want to talk about other aspects of the tree, such as the topology and edge lengths, and where the root may be. This means we need to think about how to think about unrooted phylogenies. there are some basic things we can’t take for granted in an unrooted phylogeny. We don’t, for example, know which way time goes along the branches. We don’t know which internal nodes are child nodes and which are parent nodes. We don’t know which of the edges attached to an internal node connect to older nodes and which to younger nodes. Figure 2.10: These four cladograms have the same tips and same topology, only the their layout differs. The first layout is unrooted. The other three are rooted on the red node, blue node, and orange edge. These colored elements are in the exact same topological positions in all trees. When the tree is rooted on the red or blue nodes, the base of the tree is a polytomy since these nodes have three edges attached to them. No nodes are added or removed when rooting on a node. When rooting on the orange edge, a new nroted node is added along the edge. This new node is bifurcating. The root could fall at any point in an unrooted phylogeny, either along an edge or right at an internal node. You can think of rooting a phylogeny as grabing the point that you think is the root and draggint it until all the edges point away from it (Figure ??). If you grab at some point along an edge, this creates a new node that is the root. This new root node has two edges connecting it to descendants. Since it has no edge connecting it to a parent, it differs from other internal nodes in having only two edges connected to it (instead of three, or more in the case of polytomies). The end results of rooting along a edge is that you add a node to the phylogeny and the root is resolved (not a polytomy). Things are a bit different if you root at an existing internal node. Because the existing node becomes the root, the number of nodes in the tree remains unchanged. So far so good. But since internal nodes in a bifurcating tree all have three edges connected to them, when an internal node becomes the root the root is an unresolved polytomy. This seems like a pain, so why not always root along an edge? There are a few reasons. One is that rooting along an edge requires that we pick a specific point where the root goes, for example in the middle or somewhere else. That decision can take information that we don’t have. The other is that the creation and destruction of nodes associated with rooting along edges gets cumbersome and problematic, especially when there are specific data associated with internal nodes. What information can we use to root a phylogeny? There are a couple approaches. Once is to pick the midpoint - the point forthest from any tips - as the root. If evolution proceeded at a perfectly uniform rate this could work well, but in practice rates of evolution are too variable across lineages for this to give a reliable result. The more common approach to rooting a phylogeny is to use an outgroup (Figure 2.11). If the ingroup is the group of organisms you are interested in (e.g., mammals), the outgroup is a set of animals that you strongly believe do not fall within the ingroup. If you place the root anywhere in the outgroup, then the most recent common ancestor of the ingroup will be the root of the ingroup. Figure 2.11: The root of the mammal tree is shown in red. Always be careful interpreting root position when looking at a published phylogeny. Unrooted phylogenies are often drawn is if they are rooted, just by picking a random rooting point are a good guess of where the root is. If the figure legend or text doesn’t state how the tree was rooted, best to assume that it wasn’t rigorously rooted if this is critical to the analyses at hand. 2.9 The information contained in phylogenies Thinking about phylogenies as graphs gives us very explicit ways to think about what information can be contained in a phylogeny. In the fundamental graphical sense, a phylogeny is a pair of sets – a set of nodes and a set of edges – and annotations on those entities. The topology of the phylogeny is the way in which nodes are connected by edges. If there are different connections in two phylogenies, then they have different topologies. If the annotations differ but the connections are the same, then the topolpgies are the same. Sometimes we know more and sometimes less about the topology. A fully resolved bifurcating phylogeny, where every internal node has two children, contains maximal information about the topology. A completely unresolved star phylogeny contains no information about topology. Node annotations can include: Labels. These could be species names, gene names, museum accession numbers for particular specimens, or broader clade names (eg Mammalia). Character states. The presence or absence of particular attributes (like hair), or the particular nucleotide at a particular spot in a particular gene (CGTA). Geographical locations. Whether the node is the tree root. Edge annotations can include: Length. The value and unit of length can differ, for example it can time (as in a chronogram) or expected amount of change in a particular set of characters (as in a phylogram). Directionality. An indication of which direction time goes in along each edge. This only applies in the context of a rooted phylogenies. Events. These could include a character change (such as the gain of a placenta) or a geographical change (such as an intercontinental dispersal event). Nodes need not be different in the relevant trait to have change events. For example, at a particular gene site a parent and a child node could both have an A. There could be two or more events along the edge that are compatible with this pattern, for example a change from A to C and then a change from C back to A. Edge frequencies.This is how topology support values such as bootstraps and posterior probabilities, which we’ll discuss later, are stored. Not all phylogenies have all this information. The minimum possible information a phylogeny could contain is just the number of tips. With this, you could could draw an unresolved, unlabeled cladogram (Figure 2.12A). You could then start layering information onto that phylogeny. For example, you could next add images denoting the species at the tips (Figure 2.12B). That tells you what species are in the phylogeny, but nothing about how they are related. Next you could add internal nodes and edges that indicate the topology of the phylogeny (Figure 2.12C). Once you have topology, you could display edge attributes. For example, you could scale the edge lengths by time (Figure 2.12D). At each step in this process of layering on information, the phylogeny is compatible with a very large set of possible phylogenies. At one extreme, Figure 2.12A is compatible with any phylogeny with any edge lengths for any 11 species or organisms or genes. Each added piece of information narrows that subset. When we label the tips as in Figure 2.12B, it is compatible with any phylogeny with any edge lengths for those specific species. And so on. More information provides more specificity. We could go well beyond Figure 2.12D, for example by labeling internal nodes or showing character states. The amount of information in a phylogeny varies greatly depending on a variety of factors, including what information is available, what the question at hand is, and what makes the most sense for the focused description of the biology at hand. One investigator may go to great lengths to calibrate edge lengths, for example, while another couldn’t care less about edge lengths and is only interested in topology. Figure 2.12: Adding information to a phylogeny makes it more specific. 2.10 Representation So far we have focused on phylogenies in the abstract sense as mathematical graphs and their associated annotations, and in the concrete sense as tree-like drawings that represent these relationships. To work with trees of any significant size, to infer their features from data, and to use them to analyze data, we need to be able to represent them computationally. Variables are routinely used to store numbers and text, but how can you store a whole tree and all its associated annotations? One way is to store a text representation of the tree. Newick, a phylogenetic data format ironed out over dinner at Newick’s Lobster House, does exactly this. The newick format is widely used for storing phylogenies in files. The basic idea is to designate each clade within a pair of parentheses. # Define the newick text that includes the tip labels and tree topology newick_text = &quot;(((A,B),(C,D)),E);&quot; # Create an ape phylo object from the tree text phylo_tree = read.tree( text=newick_text ) # Plot the newick_tree phylo object using the ggtree library ggtree(phylo_tree ) + # Draw the tree geom_text2(aes(label=node), col=&quot;red&quot;, nudge_x=0.1 ) + # Add the node numbers geom_tiplab( aes(label=label), offset=0.3, col=&quot;blue&quot;) + # Add the tip labels geom_nodepoint(col=&quot;red&quot;) + # Add points on nodes geom_tippoint(col=&quot;red&quot;) Figure 2.13: Defining and drawing a Newick tree. Tip labels are blue, nodes and node numbers are red, and edges are black. In Figure 2.13, you can see how to define a newick tree, convert it to a different type of representation, and then draw that. Most of the figures in this text were made using similar code. Considering just the newick specificaiton of the tree, \"(((A,B),(C,D)),E);\", you can see it built up as a series of clades. The inner-most sets of parentheses define two clades, (A,B) and (C,D). The next set of parentheses out indicates that these two clades together form a larger clade, ((A,B),(C,D)). Finally, the outermost parentheses indicate that the clade ((A,B),(C,D)) is sister to E. Commas separate sisters within clades, and the whole thing is finished off with a semicolon. The format also allows for labels of internal nodes, and the specification of branch lengths. As versatile and simple as newick is for storing trees in files, it isn’t great for storing trees in computer memory where you want to do things with them. For that, we want an object that has a more explicit representation of nodes, edges, and their annotations. This allows us to directly encode the information noted in ??, and to readilly extend the data objects as needed. The most widely used format for storing phylogenies in the R programming language is as a phylo object from the excellent ape library. The read.tree() function in the code block above creates one of these objects that we call newick_tree. In a phylo object, each node has a unique number. The first node numbers are allocated to the tip nodes, and then the internal nodes are numbered consecutively from there. Beyond this, the assignment of the node numbers is arbitrary. The numbers of the nodes that were given when we created the phylo object from the newick text are shown in red in Figure ??. Below we take a quick peek inside the phylo object we created above. The intent isn’t to learn how to manipulated trees in R quite yet, but to just show you how trees can be stored in computer memory. First, let’s take a look at the structure of the phylo object to see what variables it contains within it: str( phylo_tree ) ## List of 3 ## $ edge : int [1:8, 1:2] 6 7 8 8 7 9 9 6 7 8 ... ## $ Nnode : int 4 ## $ tip.label: chr [1:5] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; ... ## - attr(*, &quot;class&quot;)= chr &quot;phylo&quot; ## - attr(*, &quot;order&quot;)= chr &quot;cladewise&quot; We can see that there are three slots (each designated with a $) within this phylo object. Nnode is just the number of internal nodes. The real magic is edge, which encodes the topology of the tree. It is just an array with one row per edge, and two columns. The value in column 1 is the number of the node that is the parent of the edge, and the value in column 2 is the number of the node that is the child of the edge. Here are the complete contents: phylo_tree$edge ## [,1] [,2] ## [1,] 6 7 ## [2,] 7 8 ## [3,] 8 1 ## [4,] 8 2 ## [5,] 7 9 ## [6,] 9 3 ## [7,] 9 4 ## [8,] 6 5 So, in this case edge number 1 (the first row) connects node 6 to node 7. Indeed, we can see just such an edge in Figure 2.13. Try to identify each of the other edges in the array in the tree figure. There is one other important piece of information that we specified in the newick files - the tip labels. Those are located in another slot: phylo_tree$tip.label ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; We can see that this is just a vector of labels. They correspond to the labels of nodes one through five, all the tip labels, in consecutive order. That’s it. That’s all the information we specified in the newick file, all the information in the phylo object, and all the information that is specified in Figure 2.13 drawn from the phylo object. The newick tree is easy to store in files and features are easilly readable to humans, the phylo object is a powerful and flexible way to represent the tree in computer memory, and the figure we can automatically draw from the tree is easy to read at a glance. 2.11 Additional reading The ggtree book - https://yulab-smu.github.io/treedata-book/index.html ggtree vignettes - https://bioconductor.statistik.tu-dortmund.de/packages/3.1/bioc/vignettes/ggtree/inst/doc/ggtree.html References "],
["simulation.html", "Chapter 3 Simulation 3.1 Models 3.2 A simple model 3.3 Generalizing the simple model 3.4 More complex models 3.5 Model structure 3.6 Aditional resources", " Chapter 3 Simulation Build the machinery to simulate the evolution of traits on trees. Focus for now on DNA evolution. 3.1 Models Generative models The intent is a simplified representation of the process under consideration. “All models are wrong, some are useful” 3.2 A simple model Let’s start with a simple model of DNA evolution. At first we will also consider only a single nucleotide position. Imagine that when the DNA is being replicated, most of the time the appropriate nucleotide is incorporated. Some fraction of the time, at rate \\(\\mu\\), an event occurs where the appropriate nucleotides is replaced with a random nucleotide instead. The probability of selecting any of the nucleotides during one of these random replacement events is uniform (picking a C is just as probably as picking a G, for example), and the new nucleotide doesn’t depend in any way on what nucleotide was there before. It is as if you had a bag containing equal frequencies of C, G, T, and A nucleotides. As you built the new DNA strand, every so often you would replace the nucleotide you should be adding with one you instead selected by reaching into the bag with your eyes closed and picking one at random. Not all replacement events will result in an apparent change. Sometimes the appropriate nucleotide is selected by chance, even though it was picked at random. If, for example, the appropriate nucleotide was an A, under this model \\(1/4\\) of the time a replacement event occurs an A is selected by chance and there is no apparent change. In such a case, there has not been a substitution (just a replacement in kind). If the A is replaced with any of the other three nucleotides we say there has been a substitution. Because three of the four possible outcomes of an event result in a substitution, the substitution rate is \\(3\\beta\\), which, because \\(\\beta=\\mu/4\\), is equivalent to noting that the substitution is \\((3/4) \\mu\\). Because some events result in no apparent change, substitutions are only a subset of events and the substitution rate is lower than the replacement event rate. It might seem a bit odd to consider replacement events that don’t result in substitutions, but this follows naturally from a central feature we specified for the the model - the new nucleotide doesn’t depend in any way on what nucleotide was there before. If we had a process where replacements always resulted in substitutions, then excluding the a replacement in kind would require knowing which nucleotide should be placed so that we don’t select it. 3.2.1 Expected amount of change One of the primary values of a model is that it allows us to think explicitly about how much evolutionary change we expect to see under the specified process. For the simple process described here, there are two things to consider if we want to know the amount of evolutionary change. The first is the substitution rate \\(\\mu\\) (which we also know if we know \\(\\beta\\), since \\(\\mu=4\\beta\\)), and the time over which the evolutionary process acts. In Figure 3.1 the amount of evolutionary time is held constant, and the rate \\(\\mu\\) is changed. When \\(\\mu=0\\), the bottom bar, there are no replacements (black bars) and therefore no substitutions (the whole bar is the same color). Figure 3.1: Each horizontal bar is a simulation of evolution of a single nucleotide position through time, \\(t\\), for a specified value of \\(\\mu\\). Each sumulation starts out as an A. Black vertical bars correspond to replacement events, which don’t all lead to substitutions (a new color). As \\(\\mu=0\\) increases (going up on the \\(y\\) axis), the number of replacement events over the same time interval increases (Figure 3.2). This reflects the simple linear relationship \\(n=\\mu t\\), where \\(n\\) is the number of expected replacement events. Figure 3.2: The number of replacement events increases linearly with the replacement rate \\(\\mu\\). This plot is from the same simulation as that shown in Figure 3.1. The line is a linear model fit to the data. Because of the linear relationship between the number of replacements and the product \\(\\mu t\\), rate and time are conflated. In many scenarios you can’t estimate them independently. If there are a small number of replacements, for example, you can’t be sure if there is a low rate over a long time interval or a high rate over a short interval. Both would give the same result. Because they are so often confounded in phylogenetic questions, often the rate is essentially fixed at one and the unit of time for edge lengths is given as the number of expected evolutionary change rather than absolute time (years, months, etc). You will often see this length as the scale bar of published phylogenies (Figure 3.3). The exception is when you have external information, such as dated fossils, that allow you to independently estimate edge lengths and rates. Figure 3.3: A published phylogeny (Zapata et al. 2015) with a scale bar indicating branch length in terms of the expected amount of evolutionary change, rather than absolute time. 3.2.2 Expected end state The machinery above shows how a model can clarify the way we think about the expected amount of change. Many times, though, we want to know what the probability of a given end state is given a starting state, a model, and the amount of time elapsed. One way to anchor such a question is to think about the extremes - what do we expect after a very small amount of change (either a short time or a slow rate of change, or both), and what do we expect after a large amount of change? The situation is most clear after a small amount of change - we expect the end result to be the same as the starting condition. If we start with an A, for example, we expect to end with an A (Figure 3.4, left side). In this situation, if we know the starting state that information tells us a lot about the end state. Not much else matters. What should we expect, though, if there has been a large amount of change? Can we know anything at all? It turns out that we can. If there have been many replacements, one after the other, than the initial starting state really doesn’t matter at all because whatever was there will probably have been replaced multiple times. If the starting state doesn’t contain information about the end state, what does? It is the bag that you are picking the nucleotides at random from. Given enough evolutionary time, our simple model will lead the expected frequency of each nucleotide in the evolving sequence to be the same as the frequency in the bag that we randomly draw them from. Since we specified that you have the same chance of grabbing any nucleotide from the bag, eventually the probability of having each of the our nucleotides is the same, 25% (Figure 3.4, right side). If you started with a sequence that had an A and let it evolve 100 times, after enough evolutionary time had passed to reach equilibrium you would expect to get 25 C’s, 25 G’s, 25 T’s, and 25 A’s. Figure 3.4: Stacked bar plots indicating the frequency of each nucleotide after evolution for a specified amount of time. The rate of evolution is $= 0.05 $. There are 1000 replicate simulations for each value of time. At time=0 (no evolution), the end result is always the same as the initial value, which is fixed at A in these simulations. As the length of time increases, the four nucleotides converge on equal frequencies of 25% each. 3.3 Generalizing the simple model rates, equilibrium frequencies ## [,1] ## [1,] 0 ## [2,] 0 ## [3,] 0 ## [4,] 0 exponentiation 3.4 More complex models 3.5 Model structure 3.6 Aditional resources My own thinking about this material was heavilly influenced by Paul Lewis’s wonderful lectures at the annual Workshop on Molecular Evolution at Woods Hole. Some of his lectures are now available online as part of the excellent Phylo Seminar, starting with https://www.youtube.com/watch?v=1r4z0YJq580&amp;t=2111s A great introduction to continuous time models by John Huelsenbeck https://revbayes.github.io/tutorials/dice/ References "],
["inference.html", "Chapter 4 Inference", " Chapter 4 Inference A specific task - given a set of character data corresponding to the tips of a tree, what is the topology of the tree? Model is also estimated, but may or may not be of interest. Calculating the likelihood of a tree What a likelihood is maximum likelihood hueristics Bayesian “Model free” methods "],
["evaluation.html", "Chapter 5 Evaluation 5.1 Model evaluation 5.2 Topology evaluation 5.3 Sensitiviy 5.4 Confidence 5.5 Epistemology", " Chapter 5 Evaluation 5.1 Model evaluation Why not add as many parameters as you can imagine? Likelihood ratio test AIC BIC 5.2 Topology evaluation 5.3 Sensitiviy changing methods and parameters adding noise 5.4 Confidence Propogation, point estimates 5.5 Epistemology gene trees, species trees "],
["future.html", "Chapter 6 Future", " Chapter 6 Future Integrated models of genome evolution "],
["shape.html", "Chapter 7 Shape", " Chapter 7 Shape Dating Diversification Extinction, birth, death Null models "],
["character-evolution.html", "Chapter 8 Character evolution", " Chapter 8 Character evolution Comparative biology Reconstructing a single trait on trees Trait correlation Models of character change, including rate "],
["applications.html", "Chapter 9 Applications 9.1 Functional genomic data 9.2 Gene trees", " Chapter 9 Applications 9.1 Functional genomic data 9.2 Gene trees "],
["references.html", "References", " References "]
]
